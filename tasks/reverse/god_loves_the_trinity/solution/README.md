Нам даётся программа, которая:

Принимает:

login — строка.

password — строка.

modkey — строка из трёх символов, состоящая только из 0 и 1.

Обрабатывает их через функцию modulate(...), которая на выходе даёт по 6 байт (массив uint8_t[6]) для логина и пароля.

Затем сравнивает их: если login_result и pass_result равны побайтово — выводит флаг (успех).

Алгоритм: 

modulate()

    for (int i = 0; i < 6; ++i) {
        int bit_index = i % 3;
        int bit = (modkey[bit_index] == '1') ? 1 : 0;
        char c = (i < strlen(input)) ? input[i] : 0;
        out[i] = funcs[i][bit](c, i);
    }

Что происходит:

На каждый байт i (от 0 до 5) выбирается bit_index (0, 1 или 2), который указывает на символ в modkey.

В зависимости от значения этого бита (0 или 1) выбирается одна из двух функций: funcs[i][0] или funcs[i][1].

Эта функция применяется к символу c из login или password и индексу i.

Если длина строки < 6, то оставшиеся символы берутся как 0.

Функции login_mod_funcs и pass_mod_funcs разные, но имеют общие части. То есть login_result[i] и pass_result[i] формируются по разным формулам, и наша цель — подобрать такие login, password, modkey, чтобы они совпали.