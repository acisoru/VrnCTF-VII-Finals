#!/bin/bash
set -e

echo "Usage: $0 <start_team> <end_team> <parallel_deploy>"

# Default values
START_TEAM=${1:-1}
END_TEAM=${2:-5}
PARALLEL=${3:-2}

echo "[+] Deploying K3s of Health for teams $START_TEAM through $END_TEAM"
echo "[+] Running $PARALLEL deployments in parallel"

# Check if running as root
if [ "$EUID" -ne 0 ]; then
  echo "Please run as root"
  exit 1
fi


if ! command -v tmux &> /dev/null; then
  echo "[!] tmux is not installed. Installing tmux..."
  apt-get update && apt-get install -y tmux
  if [ $? -ne 0 ]; then
    echo "[!] Failed to install tmux. Falling back to sequential deployment."
    USE_TMUX=false
  else
    USE_TMUX=true
  fi
else
  USE_TMUX=true
fi


deploy_team() {
    local team_id=$1
    echo "[+] Starting deployment for Team $team_id"
    ./setup-team.sh $team_id 2>&1 | tee /tmp/team${team_id}_deploy.log
    local status=${PIPESTATUS[0]}
    if [ $status -eq 0 ]; then
        echo "[+] Team $team_id deployment completed successfully"
    else
        echo "[!] Team $team_id deployment failed. Check /tmp/team${team_id}_deploy.log for details"
    fi
    return $status
}

# Just in case
chmod +x create-template.sh
chmod +x setup-team.sh

# Cool terminal windows
if [ "$USE_TMUX" = true ]; then
    # Kill any existing session with the same name
    tmux kill-session -t ctf-deploy 2>/dev/null || true
    
    # Create a new session with a single window
    tmux new-session -d -s ctf-deploy -n "Teams"
    
    TEAM_COUNT=$((END_TEAM - START_TEAM + 1))
    
    # Create exactly the right number of panes
    # Start with one pane (index 0)
    for ((i=1; i<TEAM_COUNT; i++)); do
        # For odd numbers, split vertically
        if [ $((i % 2)) -eq 1 ]; then
            tmux split-window -v -t ctf-deploy:0
        else
            # For even numbers, split horizontally
            tmux split-window -h -t ctf-deploy:0
        fi
        # Apply tiled layout after each split
        tmux select-layout -t ctf-deploy:0 tiled
    done
    
    echo "[+] Created tmux session 'ctf-deploy' with tiled layout. Connect with: tmux attach-session -t ctf-deploy"
    echo "[+] Press Ctrl+B then D to detach from the session without stopping deployments"
fi

# Create template container if it doesn't exist
if ! lxc info k3s-ctf-template &>/dev/null; then
    echo "[+] Creating template container..."
    ./create-template.sh > /tmp/template_creation.log 2>&1
    if [ $? -ne 0 ]; then
        echo "[!] Template creation failed. Check /tmp/template_creation.log for details"
        exit 1
    fi
    echo "[+] Template container created successfully"
else
    echo "[+] Template container already exists, skipping creation"
fi

# Deploy team instances
if [ "$USE_TMUX" = true ]; then
    # Deploy in tmux panes
    # Send commands to each pane
    PANE_INDEX=0
    for team_id in $(seq $START_TEAM $END_TEAM); do
        # Send the command to the appropriate pane
        tmux send-keys -t ctf-deploy:0.$PANE_INDEX "cd $(pwd) && echo \"[+] Deploying Team $team_id\" && ./setup-team.sh $team_id" C-m
        
        echo "[+] Started deployment for Team $team_id in tmux pane $PANE_INDEX"
        PANE_INDEX=$((PANE_INDEX + 1))
    done
    
    # Attach to the session
    echo "[+] Attaching to tmux session. Press Ctrl+B then D to detach."
    tmux attach-session -t ctf-deploy
    
    echo "[+] All deployments completed"
    echo "[+] Team instances summary:"
    lxc list | grep k3s-ctf-team
else
    # Fall back to regular parallel deployment if tmux is not available
    for team_id in $(seq $START_TEAM $END_TEAM); do
        # Check how many deployments are currently running
        while [ $(jobs -r | wc -l) -ge $PARALLEL ]; do
            sleep 1
        done
        
        # Start a new deployment in the background
        deploy_team $team_id &
        
        # Small delay to avoid resource contention
        sleep 2
    done

    # Wait for all background jobs to complete
    wait

    echo "[+] All deployments completed"
    echo "[+] Team instances summary:"
    lxc list | grep k3s-ctf-team
fi

echo "[+] To clean up all instances, run: ./cleanup-all.sh $START_TEAM $END_TEAM"
