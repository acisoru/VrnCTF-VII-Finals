# Решение

## Описание задачи

В этой задаче мы имеем дело с хэш-функцией. Сервер дает нам вектор $y$ и его хэш $h$, а наша цель — найти другой вектор $y'$, который дает тот же хэш $h$, но отличается от $y$. Если мы это сделаем, сервер выдаст нам флаг.

### Цель:
Найти $y' \in \mathbb{Z}^{20}$, такой что:
1. $H(A, y') = h$,
2. $y' \neq y$,
3. Компоненты $y'$ целые числа от -2 до 2

---

В криптографии **коллизия** возникает, когда два разных входных значения дают одинаковый выход для хэш-функции. Здесь это значит, что $y$ и $y'$ разные, но их хэши равны:  
$A \cdot y \mod 67 = A \cdot y' \mod 67$

Если вычесть одно из другого, получим:  
$A \cdot (y' - y) \equiv 0 \mod 67$  
То есть разница $v = y' - y$ должна быть таким вектором, который при умножении на \( A \) дает ноль по модулю 67. Это означает, что $v$ принадлежит множеству векторов, которые матрица $A$ "обнуляет" по модулю 67. Такое множество называется **ядром** матрицы $A$ над $\mathbb{Z}_{67}$. 

Но есть условие:  $y$ и $y'$ состоят из чисел от -2 до 2, так что $v$ должен имеет компоненты в $(-4, -3, \dots, 3, 4)$, чтобы $y + v$ не выходило за эти границы.


---

## 1: Узнать секретную матрицу \( A \)

Сервер присылает пары $(y, h)$, где $h = A \cdot y \mod 67$. Матрица \( A \) — $(8 \times 20)$, и чтобы её найти, нам нужно решить систему уравнений. У нас:
- \( y \) — вектор длины 20,
- \( h \) — вектор длины 8,
- \( A \) имеет 20 столбцов, и каждый столбец влияет на \( h \).

Собираем 20 пар $( (y^{(1)}, h^{(1)}), \dots, (y^{(20)}, h^{(20)}) )$:
- Матрица $( Y = [y^{(1)} \, y^{(2)} \, \dots \, y^{(20)}] )$ — $( 20 \times 20 )$,
- Матрица $( H = [h^{(1)} \, h^{(2)} \, \dots \, h^{(20)}])$ — $( 8 \times 20 )$.

Из условия задачи:
$[ H = A \cdot Y \mod 67 ]$
Чтобы найти \( A \), нужно "разделить" \( H \) на \( Y \). Это возможно, если \( Y \) обратима.

Матрица \( Y \) обратима по модулю 67, если у неё есть обратная матрица $( Y^{-1})$, такая что:
$[ Y \cdot Y^{-1} \equiv I \mod 67 ]$
(где \( I \) — единичная матрица $( 20 \times 20 )$). Для этого определитель $\det(Y)$ не должен быть равен 0 по модулю 67. Тогда:
$[ A = H \cdot Y^{-1} \mod 67 ]$

**Почему 20?** У \( A \) 20 столбцов, и нам нужно 20 независимых уравнений (пар \( y, h \)), чтобы однозначно определить каждый столбец. Если пар меньше, решений будет много, если больше — лишние данные не нужны.

---

## 2: Поиск маленьких векторов в ядре

Теперь, когда у нас есть \( A \), нужно найти вектор \( v \), для которого $A \cdot v \equiv 0 \mod 67$, и чтобы его компоненты были небольшими (от -4 до 4).

### Как найти маленькие векторы?
Мы используем алгоритм **LLL** (Ленстры — Ленстры — Ловаса). Он берет решетку и находит в ней векторы покороче. Как это работает:
- Находим базис ядра \( A \) — набор векторов $( u_1, u_2, \dots )$, которые удовлетворяют $( A \cdot u_i \equiv 0 \mod 67 )$.
- Эти векторы могут быть большими, поэтому добавляем возможность сдвигов на 67 (например, $( 67 \cdot e_j )$, где $( e_j )$ — стандартные базисные векторы).
- Применяем LLL, чтобы получить новые векторы с маленькими компонентами.

Так как \( q = 67 \) не очень большое, а размерность 20, LLL обычно находит векторы, подходящие для нашей задачи.

---

## 3: Создаем коллизию

Когда сервер присылает новый \( y \) и \( h \), мы используем маленькие векторы \( v \):
- Пробуем \( y' = y + v \) или \( y' = y - v \).
- Проверяем, что все числа в \( y' \) от -2 до 2 и что $( y' \neq y )$.
- Если подходит, отправляем \( y' \) серверу. Так как $( A \cdot v \equiv 0)$, то:  
  $[ A \cdot y' = A \cdot (y + v) = A \cdot y + A \cdot v = A \cdot y = h \mod 67 ]$

Если первый \( v \) не сработал, пробуем другие, пока не найдем подходящий.

---

## 4: Как это собрать в коде

Общий план решения:
1. **Собираем данные**: Запрашиваем у сервера 20 пар \( (y, h) \), следим, чтобы \( y \) были независимыми (проверяем ранг матрицы \( Y \)).
2. **Восстанавливаем \( A \)**: Вычисляем $( A = H \cdot Y^{-1} \mod 67 )$.
3. **Строим решетку**: Находим ядро \( A \), добавляем сдвиги по 67 и применяем LLL для поиска маленьких векторов.
4. **Ищем коллизию**: Для нового \( y \) пробуем \( y + v \) или \( y - v \), проверяем условия и отправляем \( y' \).


---

[Решение на SageMath](sploit.sage)